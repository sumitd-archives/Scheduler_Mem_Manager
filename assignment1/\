#include "my_pthread_t.h"
#include <stdlib.h>
#include <time.h>
#include <stdio.h>
#include <signal.h>
#include <stdbool.h>

Node * running = NULL;
Node * head = NULL;
Node * tail = NULL;
sigset_t set;
bool main_exists = false;
ucontext_t main_context;

void TimerHandlerInit();

void CreateThread() {
    pthread_t thread;
    printf("Creating thread\n");
    my_pthread_create(&thread , NULL , &function , NULL);
}

void NewThreadHandler(int signum) {
   //sigemptyset(&set);
   //sigaddset(&set , SIGINT);
   //sigprocmask(SIG_UNBLOCK , &set , NULL);
   CreateThread();
}
 
timer_t timer1 , timer2;
void timerHandler(int signum , siginfo_t *si , void * uc) {
   //unblock this signal since it gets blocked when the handler is 
   //still executing
   sigemptyset(&set);
   sigaddset(&set , SIGRTMIN);
   //sigprocmask(SIG_UNBLOCK , &set , NULL);
   //TimerHandlerInit();
   timer_t * tidp;
   tidp = si->si_value.sival_ptr;

   if ( *tidp == timer1 ) {
        Scheduler();
   }
   // else if ( *tidp == timer2 )
   //     CreateThread();
}

void TimerHandlerInit() {
   struct sigaction sa;
   int signum = SIGRTMIN;
   sa.sa_flags = SA_SIGINFO;
   sa.sa_sigaction = timerHandler;
   //sigemptyset(&sa.sa_mask);
   if (sigaction(signum , &sa , NULL) == -1) {
      perror("error in registering handler\n");
   }
}

void createTimer(timer_t * timerId , int interval) {
    struct sigevent event_init;
    event_init.sigev_notify = SIGEV_SIGNAL;
    int signum = SIGRTMIN;
    event_init.sigev_signo = signum;
    event_init.sigev_value.sival_ptr = timerId;
    timer_create(CLOCK_REALTIME , & event_init , timerId);

    struct itimerspec its;
    its.it_interval.tv_sec = 0;
    its.it_interval.tv_nsec = interval*1000000;
    its.it_value.tv_sec = 0;
    its.it_value.tv_nsec = interval*1000000;
    timer_settime(*timerId , 0 , &its , NULL);
}

void function (void) {
    printf("\ninside fucntion \n");
    //while(1) {}
    my_pthread_exit();
    //while(1) {
    //}
}

void my_pthread_create(pthread_t * thread, pthread_attr_t * attr, void (*function)(void), void * arg) {
    my_pthread_t * tcb = (my_pthread_t*)malloc(sizeof(my_pthread_t));
    ucontext_t * new_thread = (ucontext_t*)malloc(sizeof(ucontext_t));
    getcontext(new_thread);
    //Mutex required
    *thread = unique_id++;
    new_thread->uc_link = 0;
    new_thread->uc_stack.ss_sp = malloc(MEM);
    new_thread->uc_stack.ss_size = MEM;
    new_thread->uc_stack.ss_flags = 0;
    makecontext(new_thread , function , 0);
    tcb->id = thread;
    tcb->context = new_thread;
    tcb->burst = DEFAULT_BURST;
    tcb->state = RUNNING;
    tcb->ret_val_ptr = NULL;
    PushToFront(tcb);
}

void my_pthread_exit(void * value_ptr) {
    /*disable the scheduler interrupt.
    The scheduler shouldn't be called while the resources 
    are being cleaned up
    */

    /*Change the state to terminated and add this thread to 
    the list of completed threads*/
    running->tcb->state = TERMINATED;
    running->tcb->ret_val_ptr = val_ptr;
    CompletedListAdd(running->tcb);

    /*Invalidate this thread.
    Shouldn't be scheduled again*/
    running->next = NULL;
    running->prev = NULL;
    running = NULL;
    
    //call the scheduler
    Scheduler();
}

void my_pthread_join (pthread_t thread , void ** value_ptr) {
    //Check if thread present in completed list and get the return value
    //else wait till the thread completed
    while(!ThreadCompleted(thread , ptr)) {}
    
    //free up the terminated thread's resources
    FreeResources(thread);
    return 0;
}

Node * PopulateContext(ucontext_t * context) {
    my_pthread_t * tcb = (my_pthread_t*)malloc(sizeof(my_pthread_t));
    pthread_t * thread = (pthread_t*)malloc(sizeof(pthread_t));
    *thread = unique_id++;
    tcb->id = thread;
    getcontext(context);
    tcb->context = context;
    tcb->burst = DEFAULT_BURST;
    Node * new_node = (Node*)malloc(sizeof(Node));
    new_node->tcb = tcb;
    new_node->tcb->last_start_time = GetCurrentTime();
    return new_node;
}

CompletedListAdd(Node * thread) {
    Completed * node = (Completed*)malloc(sizeof(Completed));
    node->next = NULL;
    if (completed_head == NULL) {
        completed_head = node;
        return;
    }
    //Add at the end
    Completed * temp = completed_head;
    while (temp->next != NULL) {
        temp=temp->next;  
    }
    temp->next = node;
}

bool ThreadCompleted(pthread_t thread , void **ptr) {
    Completed * temp = completed_head;
    while (temp != NULL) {
        if (*(temp->tcb->id) == thread) {
            *ptr = temp->tcb->ret_val_ptr;
        }
        return true;
    }
    return false;  
}

void FreeResources(pthread_t thread) {
    Completed * temp = completed_head;
    while ((temp != NULL) && *(temp->next->tcb->id) != thread) {
        temp = temp->next;
    }
    
    if (temp == NULL) {
        return;
    }
    
    //free resources
    Completed * node = temp->next;
    free(node->tcb->context->uc_stack.ss_sp);    
    node->tcb->context->uc_stack.ss_sp = NULL;
    free(node->tcb->context);
    node->tcb->context = NULL;
    free(node->tcb);
    node->tcb = NULL;
    temp->next = node->next;
    node->next = NULL:
    free(node);
    node = NULL;
}

void PushToFront(my_pthread_t * tcb) {
    //create new tcb node
    Node * new_node = (Node*)malloc(sizeof(Node));
    new_node->tcb = tcb;
    new_node->prev = NULL;
    if (NULL == head) {
        new_node->next == NULL;
        tail = new_node;  
    }
    else {
        new_node->next = head;
        head->prev = new_node;
    }    
    head = new_node;
}

void PushToEnd(Node * node) {
    if (NULL == head) {
        node->prev = NULL;
        head = node;
    }
    else {
       tail->next = node;
       node->prev = tail;
    }
    node->next = NULL;
    tail = node;
}

Node * GetHead() {
    if (head == NULL) {
        return NULL;
    }
    Node * temp = head;
    if (head->next == NULL) {
        head = NULL;
    }
    else {
        head = head->next;
        head->prev = NULL;
    }
    return temp;    
}

long long GetCurrentTime() {
    long ms;
    long sec;    
    long long time_ms;  
    struct timespec spec;
    clock_gettime(CLOCK_MONOTONIC , &spec);
    sec = spec.tv_sec;
    ms = spec.tv_sec;
    time_ms = sec * 1000 + ms;
    return time_ms;
}

void Scheduler() {
   if (!main_exists) {
      //This is the first time the scheduler has been invoked.
      //Add the main context to the queue such that the main thread can 
      //scheduled as well
      Node * node = PopulateContext(&main_context);
      running = node;
      main_exists = true;
   }
 
   if (running != NULL) {
       if (head == NULL) {
           sigprocmask(SIG_UNBLOCK , &set , NULL);
           //only the main thread running . nothing to schedule.
           return;
       }
       //check if the running thread has executed for complete time slice
       long long execution_time = GetCurrentTime() -  running->tcb->last_start_time;
       if (execution_time < (running->tcb->burst)) {
           //continue executing
           return;
       }
       else {
           //decrease priority by pushing at end and increase next burst time
           running->tcb->last_start_time = GetCurrentTime();
           running->tcb->burst +=  DEFAULT_BURST;
           PushToEnd(running);
           //get the head
           Node * current = running;
           running = GetHead(); 
           if (NULL == running) {
               return;
           }
           swapcontext(current->tcb->context , running->tcb->context);
       }
   }
   else if (NULL == head) {
       //nothing to schedule
       return;
   }
   else {
       running = GetHead();
       setcontext(running->tcb->context);
   }
}
          
int main()
{
    signal(SIGINT , NewThreadHandler);
    TimerHandlerInit();
    createTimer(&timer1 , 500);
    createTimer(&timer2 , 100);
    while  (1) {}
}
